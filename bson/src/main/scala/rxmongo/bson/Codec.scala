/*
 * Copyright © 2015 Reactific Software LLC. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package rxmongo.bson

import akka.util.{ ByteString, ByteStringBuilder, ByteIterator }

import java.util.Date
import java.util.regex.Pattern

import scala.util.{ Failure, Success, Try }

/** Encoder from T to ByteString
  *
  * RxMongo uses Encoder[T] implicit objects to translate the various case classes that represents Mongo documents
  * info the corresponding ByteString so they can be transmitted to Mongo. RxMongo users can also implement this trait
  * as an implicit object so that their types, T, can be converted into ByteString that can be similarly sent to Mongo.
  * Alternatively, Encoder instances can be generated by the RxMongo macros which makes using the Encoder with case
  * classes as simple as a one line declaration of an implicit value.
  *
  * An Encoder should only create whole BSON documents which means either an object or an array. For smaller bson types,
  * utilize the methods of the ByteStringBuilderPimp class.
  *
  * @tparam T The type from which this Encoder encodes
  */

trait Encoder[T] {

  /** Indicate the TypeCode of T
    * To accurately construct sequences of objects using this Encoder, the basic BSON type for T must be known.
    * Usually, the default value, ObjectCode, is appropriate for user defined case classes but if T is any of the
    * other types of BSON values, the encoder should provide the typeCode here.
    */
  val code : TypeCode = ObjectCode

  /** Extract the name of the TypeCode
    *
    * @return The name of the BSON Type for this encoder.
    */
  def typeName : String = code.toString

  /** Add value T to a ByteStringBuilder
    *
    * @param value The value, T, to be written to the builder
    * @param builder The ByteStringBuilder to which the value of type T should be written
    * @return The ByteStringBuilder
    */
  def write(value : T, builder : BSONBuilder) : BSONBuilder

  def write(value : T, builder : ByteStringBuilder) : ByteString = {
    val bsb = BSONBuilder(builder)
    write(value, bsb).wrapAndTerminate
  }

  /** Convert T into ByteString
    * This is a convenience to avoid having to create a ByteStringBuilder and pass it to the other write function.
    * Instead a builder is created and sized as specified for the intended object (default 512). The value is then
    * written using the other write overload and the ByteString is extracted from the builder.
    * @param value The value to be written to the ByteString
    * @return A ByteString that corresponds to the value T written as BSON bytes.
    */
  def write(value : T) : ByteString = {
    val bsb = BSONBuilder()
    write(value, bsb).wrapAndTerminate
  }

  /** Convenience method to get an Option[BSONValue]
    *
    * @param value The value, T, to write to BSON
    * @return None if T cannot be written, Some[BSONValue] otherwise
    */
  def writeOption(value : T) : Option[ByteString] = Try {
    Option(write(value))
  } match {
    case Success(x) ⇒ x
    case Failure(x) ⇒ None
  }

  /** Write In A Try Block.
    * Performs the write operation in a Try block so exceptions are caught and returned in the Try[ByteString] result.
    * @param value The value of type T that should be written to ByteString
    * @return A Try[ByteString] containing either the written ByteString or the exception that occurred
    */
  def tryWrite(value : T) : Try[ByteString] = Try { write(value) }
}

/** Decoder from ByteIterator to T
  *
  * RxMongo uses Decoder[T] implicit objects to translate the ByteString streams returning from Mongo into the
  * various case classes that represents Mongo documents. RxMongo users can also implement this trait
  * as an implicit object so that their types, T, can be converted from ByteString received from Mongo.
  * Alternatively, Decoder instances can be generated by the RxMongo macros which makes using the Decoder with case
  * classes as simple as a one line declaration of an implicit value.
  *
  * An Decoder should only interpret whole BSON documents which means either an object or an array. For smaller bson
  * types, utilize the methods of the ByteIteratorPimp class.
  *
  * @tparam T The type from which this Encoder encodes
  */
trait Decoder[T] extends ((ByteIterator) ⇒ T) {

  def read(value : BSONValue) : T = read(value.toByteString.iterator)

  def apply(itr : ByteIterator) : T = read(itr)

  /** Convert ByteIterator Into T
    *
    * @param itr The ByteIterator from which the value for T is read
    * @return A T that results from reading T from the ByteIterator
    */
  def read(itr : ByteIterator) : T

  /** Convenience method to get an Option[T]
    * @param itr BSONValue to be converted to T
    * @return None if the value cannot be read, Some[T] otherwise
    */
  def readOption(itr : ByteIterator) : Option[T] = Try {
    Option(read(itr))
  } match {
    case Success(x) ⇒ x
    case Failure(x) ⇒ None
  }

  /** Read In a Try Block.
    * Performs the read operation in a Try block so exceptions are caught and returned in the Try
    * @param itr The ByteIterator to read from
    * @return A Try[T] containing either the read T value or the exception that occurred
    */
  def tryRead(itr : ByteIterator) : Try[T] = Try { read(itr) }
}

/** Coder/Decoder (Codec) between type T and BSON Binary format
  *
  * The Codec trait simply combines the Encoder[T] with the Decoder[T] so that a single implicit object can be
  * declared that handles both encoding and decoding of T.
  *
  * @tparam T The type from which this Codec encodes and to which it decodes
  */
trait Codec[T] extends Decoder[T] with Encoder[T]

trait DocumentCodec[T] extends Codec[T] {

  def read(itr : ByteIterator) : T = {
    read(BSONDocument(itr))
  }

  def read(doc : BSONDocument) : T
}

object Codec {

  implicit object DoubleCodec extends Codec[Double] {
    override val code = DoubleCode
    def read(itr : ByteIterator) : Double = itr.getDouble
    def write(value : Double, bldr : BSONBuilder) : BSONBuilder = { bldr.bldr.putDouble(value); bldr }
  }

  implicit object StringCodec extends Codec[String] {
    override val code = StringCode
    def read(itr : ByteIterator) : String = itr.getStr
    def write(value : String, bldr : BSONBuilder) : BSONBuilder = { bldr.bldr.putStr(value); bldr }
  }

  implicit object BSONObjectCodec extends Codec[BSONObject] {
    def read(itr : ByteIterator) : BSONObject = { itr.getObject }
    def write(value : BSONObject, bldr : BSONBuilder) : BSONBuilder = { bldr.bldr.putObject(value); bldr }
  }

  implicit object BSONArrayCodec extends Codec[BSONArray] {
    override val code = ArrayCode
    def read(itr : ByteIterator) : BSONArray = { itr.getArray }
    def write(value : BSONArray, bldr : BSONBuilder) : BSONBuilder = { bldr.bldr.putArray(value); bldr }
  }

  implicit object BinaryCodec extends Codec[(BinarySubtype, Array[Byte])] {
    override val code = BinaryCode
    def read(itr : ByteIterator) : (BinarySubtype, Array[Byte]) = itr.getBinary
    def write(value : (BinarySubtype, Array[Byte]), bldr : BSONBuilder) : BSONBuilder = {
      bldr.bldr.putBinary(value._1, value._2)
      bldr
    }
  }

  implicit object ObjectIDCodec extends Codec[Array[Byte]] {
    override val code = ObjectIDCode
    def read(itr : ByteIterator) : Array[Byte] = itr.getObjectID
    def write(value : Array[Byte], bldr : BSONBuilder) : BSONBuilder = {
      bldr.bldr.putObjectID(value)
      bldr
    }
  }

  implicit object BooleanCodec extends Codec[Boolean] {
    override val code = BooleanCode
    def read(itr : ByteIterator) : Boolean = itr.getBoolean
    def write(value : Boolean, bldr : BSONBuilder) : BSONBuilder = { bldr.bldr.putBoolean(value); bldr }
  }

  implicit object DateCodec extends Codec[Date] {
    override val code = DateCode
    def read(itr : ByteIterator) : Date = new Date(itr.getLong)
    def write(value : Date, bldr : BSONBuilder) : BSONBuilder = { bldr.bldr.putLong(value.getTime); bldr }
  }

  implicit object RegexCodec extends Codec[Pattern] {
    override val code = RegexCode
    def read(itr : ByteIterator) : Pattern = itr.getRegex
    def write(value : Pattern, bldr : BSONBuilder) : BSONBuilder = { bldr.bldr.putRegex(value); bldr }
  }

  implicit object DBPointerCodec extends Codec[(String, Array[Byte])] {
    override val code = DBPointerCode
    def read(itr : ByteIterator) : (String, Array[Byte]) = itr.getDBPointer
    def write(value : (String, Array[Byte]), bldr : BSONBuilder) : BSONBuilder = {
      bldr.bldr.putDBPointer(value._1, value._2)
      bldr
    }
  }

  object JavaScriptCodec extends Codec[String] {
    override val code = JavaScriptCode
    def read(itr : ByteIterator) : String = itr.getStr
    def write(value : String, bldr : BSONBuilder) : BSONBuilder = { bldr.bldr.putStr(value); bldr }
  }

  object SymbolCodec extends Codec[String] {
    override val code = SymbolCode
    def read(itr : ByteIterator) : String = itr.getStr
    def write(value : String, bldr : BSONBuilder) : BSONBuilder = { bldr.bldr.putStr(value); bldr }
  }

  implicit object ScopedJavaScriptCodec extends Codec[(String, BSONObject)] {
    def read(itr : ByteIterator) : (String, BSONObject) = itr.getScopedJavaScript
    def write(value : (String, BSONObject), bldr : BSONBuilder) : BSONBuilder = {
      bldr.bldr.putScopedJavaScript(value._1, value._2)
      bldr
    }
  }

  implicit object IntCodec extends Codec[Int] {
    override val code = IntegerCode
    def read(itr : ByteIterator) : Int = itr.getInt
    def write(value : Int, bldr : BSONBuilder) : BSONBuilder = { bldr.bldr.putInt(value); bldr }
  }

  object TimestampCodec extends Codec[Long] {
    override val code = TimestampCode
    def read(itr : ByteIterator) : Long = itr.getLong
    def write(value : Long, bldr : BSONBuilder) : BSONBuilder = { bldr.bldr.putLong(value); bldr }
  }

  implicit object LongCodec extends Codec[Long] {
    override val code = LongCode
    def read(itr : ByteIterator) : Long = itr.getLong
    def write(value : Long, bldr : BSONBuilder) : BSONBuilder = { bldr.bldr.putLong(value); bldr }
  }

  implicit object ByteStringCodec extends Codec[ByteString] {
    override val code : TypeCode = ObjectCode
    def read(itr : ByteIterator) : ByteString = itr.toByteString
    def write(value : ByteString, bldr : BSONBuilder) : BSONBuilder = { bldr.bldr ++= value; bldr }
  }

}
